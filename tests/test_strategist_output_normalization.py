import json
import pytest
from typing import Any, Dict
from unittest.mock import MagicMock, patch
from src.agents.strategist import StrategistAgent
from src.graph.graph import run_strategist


def _mock_llm_response(payload: Dict[str, Any]) -> MagicMock:
    response = MagicMock()
    response.text = json.dumps(payload)
    return response


class TestStrategistNormalization:
    
    def setup_method(self):
        self.agent = StrategistAgent(api_key="dummy_key")

    def test_normalize_dict_with_strategies_list(self):
        """Case: parsed = {'strategies': [{'title': 'A'}, {'title': 'B'}]}"""
        parsed = {"strategies": [{"title": "A"}, {"title": "B"}]}
        normalized = self.agent._normalize_strategist_output(parsed)
        assert isinstance(normalized, dict)
        assert "strategies" in normalized
        assert len(normalized["strategies"]) == 2
        assert normalized["strategies"][0]["title"] == "A"

    def test_normalize_dict_with_strategies_dict(self):
        """Case: parsed = {'strategies': {'title': 'A'}} -> convert to list"""
        parsed = {"strategies": {"title": "A"}}
        normalized = self.agent._normalize_strategist_output(parsed)
        assert isinstance(normalized["strategies"], list)
        assert len(normalized["strategies"]) == 1
        assert normalized["strategies"][0]["title"] == "A"

    def test_normalize_list_of_dicts(self):
        """Case: parsed = [{'title': 'A'}, {'title': 'B'}] -> wrap in dict"""
        parsed = [{"title": "A"}, {"title": "B"}]
        normalized = self.agent._normalize_strategist_output(parsed)
        assert isinstance(normalized, dict)
        assert "strategies" in normalized
        assert len(normalized["strategies"]) == 2

    def test_normalize_single_strategy_dict_without_key(self):
        """Case: parsed = {'title': 'A', ...} -> wrap in strategies list"""
        parsed = {"title": "A", "objective_type": "descriptive"}
        normalized = self.agent._normalize_strategist_output(parsed)
        assert isinstance(normalized, dict)
        assert "strategies" in normalized
        assert len(normalized["strategies"]) == 1
        assert normalized["strategies"][0]["title"] == "A"

    def test_normalize_feature_engineering_aliases(self):
        parsed = {
            "strategies": [
                {
                    "title": "A",
                    "feature_engineering_strategy": [{"technique": "interaction", "columns": ["x", "y"]}],
                }
            ]
        }
        normalized = self.agent._normalize_strategist_output(parsed)
        strategy = normalized["strategies"][0]
        assert isinstance(strategy.get("feature_engineering"), list)
        assert strategy.get("feature_engineering") == strategy.get("feature_engineering_strategy")

    def test_normalize_garbage(self):
        """Case: parsed = 'garbage' or None -> empty strategies"""
        assert self.agent._normalize_strategist_output("garbage")["strategies"] == []
        assert self.agent._normalize_strategist_output(None)["strategies"] == []
        assert self.agent._normalize_strategist_output(123)["strategies"] == []

    def test_validate_required_columns_detects_invalid_names(self):
        payload = {
            "strategies": [
                {"title": "s1", "required_columns": ["valid_a", "invalid_x"]},
                {"title": "s2", "required_columns": [{"name": "valid_b"}, {"column": "invalid_y"}]},
            ]
        }
        validation = self.agent._validate_required_columns(payload, ["valid_a", "valid_b"])
        assert validation["status"] == "invalid_required_columns"
        assert validation["invalid_count"] == 2
        assert len(validation["invalid_details"]) == 2

    def test_build_strategy_spec_includes_target_columns(self):
        payload = {
            "strategies": [
                {
                    "title": "Churn Plan",
                    "objective_type": "predictive",
                    "target_columns": ["churn_flag"],
                    "required_columns": ["customer_id", "churn_flag"],
                }
            ]
        }

        spec = self.agent._build_strategy_spec_from_llm(
            payload,
            data_summary='{"primary_target":"churn_flag"}',
            user_request="Predict churn",
        )

        assert spec.get("target_columns") == ["churn_flag"]
        assert (spec.get("evaluation_plan") or {}).get("target_columns") == ["churn_flag"]

    def test_build_strategy_spec_reads_feature_engineering_alias(self):
        payload = {
            "strategies": [
                {
                    "title": "FE Plan",
                    "objective_type": "predictive",
                    "feature_engineering": [{"technique": "log_transform", "columns": ["income"]}],
                }
            ]
        }
        spec = self.agent._build_strategy_spec_from_llm(
            payload,
            data_summary="{}",
            user_request="Predict value",
        )
        assert isinstance(spec.get("feature_engineering"), list)
        assert (spec.get("evaluation_plan") or {}).get("feature_engineering") == spec.get("feature_engineering")

    @patch.dict("os.environ", {"STRATEGIST_COLUMN_REPAIR_ATTEMPTS": "1"})
    def test_generate_strategies_repairs_required_columns_with_inventory(self):
        initial = {
            "strategies": [
                {
                    "title": "risk",
                    "objective_type": "predictive",
                    "required_columns": ["ps_car_01", "target"],
                    "recommended_evaluation_metrics": ["auc"],
                }
            ]
        }
        repaired = {
            "strategies": [
                {
                    "title": "risk",
                    "objective_type": "predictive",
                    "required_columns": ["ps_car_01_cat", "target"],
                    "recommended_evaluation_metrics": ["auc"],
                }
            ]
        }
        self.agent.model.generate_content = MagicMock(
            side_effect=[_mock_llm_response(initial), _mock_llm_response(repaired)]
        )
        output = self.agent.generate_strategies(
            data_summary="summary",
            user_request="goal",
            column_inventory=["ps_car_01_cat", "target"],
            column_sets={"all_features": ["ps_*"]},
        )
        assert output["column_validation"]["status"] == "ok"
        assert output["column_validation"]["invalid_count"] == 0
        assert output["strategies"][0]["required_columns"] == ["ps_car_01_cat", "target"]


class TestGraphStrategistIntegration:
    
    @patch("src.graph.graph.strategist")
    def test_run_strategist_handles_list_return_legacy(self, mock_strategist):
        """
        Simulate strategist.generate_strategies returning a LIST (legacy bug).
        run_strategist must catch it and form a valid state update.
        """
        # Simulate legacy behavior: returning a list directly
        mock_output = [{"title": "Legacy Strategy", "objective_type": "predictive"}]
        mock_strategist.generate_strategies.return_value = mock_output
        
        # Minimal state
        state = {
            "business_objective": "Test Goal",
            "data_summary": "Some data",
            "run_id": "test_run"
        }
        
        # Mock other dependencies if needed (none strictly needed for this logic branch)
        
        result = run_strategist(state)
        
        # Assertions
        assert "strategies" in result
        strategies_wrapper = result["strategies"]
        assert "strategies" in strategies_wrapper
        strategies_list = strategies_wrapper["strategies"]
        
        assert isinstance(strategies_list, list)
        assert len(strategies_list) == 1
        assert strategies_list[0]["title"] == "Legacy Strategy"
        # Strategy spec falls back to empty dict if not dict result
        assert result.get("strategy_spec") == {}

    @patch("src.graph.graph.strategist")
    def test_run_strategist_handles_dict_return(self, mock_strategist):
        """
        Simulate normal V2 behavior: returning a DICT.
        """
        mock_output = {
            "strategies": [{"title": "Modern Strategy"}],
            "strategy_spec": {"spec": "details"}
        }
        mock_strategist.generate_strategies.return_value = mock_output
        
        state = {"business_objective": "Test", "run_id": "test_run"}
        result = run_strategist(state)
        
        assert result["strategies"]["strategies"][0]["title"] == "Modern Strategy"
        assert result["strategy_spec"]["spec"] == "details"

    @patch("src.graph.graph.strategist")
    def test_run_strategist_passes_inventory_and_column_sets(self, mock_strategist):
        mock_strategist.generate_strategies.return_value = {"strategies": [{"title": "s"}]}
        state = {
            "business_objective": "Test",
            "run_id": "test_run",
            "column_inventory_columns": ["a", "b", "target"],
            "column_sets": {"pre_decision": ["a", "b"]},
        }
        run_strategist(state)
        _, kwargs = mock_strategist.generate_strategies.call_args
        assert kwargs["column_inventory"] == ["a", "b", "target"]
        assert kwargs["column_sets"] == {"pre_decision": ["a", "b"]}
