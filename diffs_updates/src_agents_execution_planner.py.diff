diff --git a/src/agents/execution_planner.py b/src/agents/execution_planner.py
index 7bdf5f7..c750734 100644
--- a/src/agents/execution_planner.py
+++ b/src/agents/execution_planner.py
@@ -545,16 +545,17 @@ def _sync_execution_contract_outputs(contract: Dict[str, Any], contract_min: Dic
 
     merged_outputs: List[str] = []
     seen_outputs: set[str] = set()
-    for path in (contract.get("required_outputs") or []) + min_required_files:
-        if not path:
-            continue
-        if not is_probably_path(str(path)):
+    for item in (contract.get("required_outputs") or []) + min_required_files:
+        if isinstance(item, dict):
+            path = item.get("path") or ""
+        else:
+            path = str(item) if item else ""
+        if not path or not is_probably_path(path):
             continue
-        normalized = str(path)
-        if normalized in seen_outputs:
+        if path in seen_outputs:
             continue
-        seen_outputs.add(normalized)
-        merged_outputs.append(normalized)
+        seen_outputs.add(path)
+        merged_outputs.append(path)
     if merged_outputs:
         contract["required_outputs"] = merged_outputs
 
@@ -1628,7 +1629,7 @@ def _create_v41_skeleton(
           "canonical_columns_compact": compact_column_representation(available_cols, max_display=40)
           if feature_selectors
           else {},
-        "required_outputs": ["data/cleaned_data.csv"],
+        "required_outputs": [],
         
         "iteration_policy": {
             "max_iterations": 3,
@@ -2847,9 +2848,8 @@ def build_contract_min(
     if not isinstance(full_artifact_requirements, dict):
         full_artifact_requirements = {}
 
-    # Dynamic required_outputs: trust LLM-determined outputs, only enforce
-    # cleaned_data.csv as universal safety net.
-    minimal_safety = ["data/cleaned_data.csv"]
+    # Dynamic required_outputs: trust deliverables-driven outputs from contract.
+    # Safety nets removed — invariants are enforced by the deliverable linter.
 
     def _extract_paths_from_outputs(raw_outputs: list) -> List[str]:
         """Extract path strings from a list that may contain str or dict items."""
@@ -2867,15 +2867,11 @@ def build_contract_min(
 
     llm_outputs = contract.get("required_outputs")
     if isinstance(llm_outputs, list) and llm_outputs:
-        # Trust LLM-determined outputs, only ensure minimal safety
         required_outputs = _extract_paths_from_outputs(llm_outputs)
-        for safe in minimal_safety:
-            if safe not in required_outputs:
-                required_outputs.append(safe)
     else:
-        # Fallback: artifact_requirements + minimal safety
+        # Fallback: artifact_requirements
         full_required_files = _extract_required_paths(full_artifact_requirements)
-        required_outputs = list(dict.fromkeys((full_required_files or []) + minimal_safety))
+        required_outputs = list(dict.fromkeys(full_required_files or []))
 
     # P1.5: Infer feature selectors for wide datasets
     feature_selectors = []
@@ -5593,20 +5589,8 @@ class ExecutionPlannerAgent:
             return cleaned or "deliverable"
 
         def _infer_deliverable_kind(path: str) -> str:
-            lower = str(path).lower()
-            if "plots" in lower or lower.endswith((".png", ".jpg", ".jpeg", ".svg")):
-                return "plot"
-            if lower.endswith(".csv"):
-                return "dataset"
-            if lower.endswith(".json"):
-                if "metrics" in lower:
-                    return "metrics"
-                if "weights" in lower:
-                    return "weights"
-                if "alignment" in lower or "report" in lower:
-                    return "report"
-                return "json"
-            return "artifact"
+            from src.utils.contract_accessors import _infer_kind_from_path
+            return _infer_kind_from_path(path)
 
         def _default_deliverable_description(path: str, kind: str) -> str:
             known = {
@@ -5811,8 +5795,30 @@ class ExecutionPlannerAgent:
                 _add("data/scored_rows.csv", False, "predictions",
                      "Optional scored rows for descriptive analysis.", owner="ml_engineer")
 
+            # Kaggle / competition detection: deterministic guardrail
+            if _detect_submission_requirement():
+                sub_path = _resolve_submission_path(spec_obj)
+                _add(sub_path, True, "submission",
+                     "Submission file for competition/leaderboard.", owner="ml_engineer")
+
             return deliverables
 
+        def _detect_submission_requirement() -> bool:
+            """Deterministic detection of Kaggle/competition submission requirement."""
+            signal = (business_objective or "").lower()
+            strategy_obj = strategy if isinstance(strategy, dict) else {}
+            signal += " " + str(strategy_obj.get("analysis_type") or "").lower()
+            signal += " " + str(strategy_obj.get("title") or "").lower()
+            return any(tok in signal for tok in ["kaggle", "submission", "competition", "leaderboard", "submit"])
+
+        def _resolve_submission_path(spec_obj: Dict[str, Any]) -> str:
+            """Resolve submission file path from contract or default."""
+            eval_spec = spec_obj.get("evaluation_spec") or {}
+            sub_cfg = eval_spec.get("submission") or {}
+            if isinstance(sub_cfg, dict) and sub_cfg.get("path"):
+                return str(sub_cfg["path"])
+            return "data/submission.csv"
+
         def _apply_deliverables(contract: Dict[str, Any]) -> Dict[str, Any]:
             if not isinstance(contract, dict):
                 return {}
@@ -5828,17 +5834,8 @@ class ExecutionPlannerAgent:
             deliverables = _ensure_unique_deliverable_ids(deliverables)
             spec["deliverables"] = deliverables
             contract["spec_extraction"] = spec
-            
-            # Build required_outputs from deliverables
-            req_outputs = [item["path"] for item in deliverables if item.get("required")]
-
-            # Safety net: only cleaned_data.csv is universally forced.
-            # All other outputs (scored_rows, metrics, alignment_check) are determined
-            # by _derive_deliverables based on objective_type — no more hardcoded forcing.
-            if "data/cleaned_data.csv" not in req_outputs:
-                req_outputs.append("data/cleaned_data.csv")
 
-            # Normalize paths: ensure data/ prefix
+            # Auto-sync: required_outputs = paths of required deliverables (List[str] for compat)
             def _normalize_path(p: str) -> str:
                 known = ["metrics.json", "alignment_check.json", "scored_rows.csv", "cleaned_data.csv"]
                 import os
@@ -5847,7 +5844,7 @@ class ExecutionPlannerAgent:
                     return f"data/{base}"
                 return p
 
-            contract["required_outputs"] = [_normalize_path(p) for p in req_outputs]
+            contract["required_outputs"] = [_normalize_path(d["path"]) for d in deliverables if d.get("required")]
 
             artifact_reqs = contract.get("artifact_requirements", {})
             if isinstance(artifact_reqs, dict):
@@ -5871,6 +5868,79 @@ class ExecutionPlannerAgent:
 
             return contract
 
+        def _lint_deliverable_invariants(contract: Dict[str, Any], objective_type: str) -> List[Dict[str, Any]]:
+            """Validate deliverable invariants by kind/owner.
+
+            Returns list of structured missing_invariants. Does NOT mutate contract.
+            """
+            spec = contract.get("spec_extraction") or {}
+            deliverables = spec.get("deliverables") or []
+            missing: List[Dict[str, Any]] = []
+
+            for d in deliverables:
+                if not isinstance(d, dict):
+                    continue
+                if not d.get("kind"):
+                    missing.append({
+                        "invariant": "explicit_kind_required",
+                        "severity": "error",
+                        "message": f"Deliverable '{d.get('path')}' is missing explicit 'kind' field.",
+                        "deliverable_path": d.get("path"),
+                    })
+
+            # INV-1: DE stage requires at least one required dataset(owner=data_engineer)
+            if not any(isinstance(d, dict) and d.get("required") and d.get("kind") == "dataset"
+                       and d.get("owner") == "data_engineer" for d in deliverables):
+                missing.append({
+                    "invariant": "de_requires_dataset",
+                    "severity": "error",
+                    "message": "Data engineer stage requires at least one required deliverable with kind='dataset' and owner='data_engineer'.",
+                    "expected_kind": "dataset", "expected_owner": "data_engineer",
+                })
+
+            # INV-2: Model training requires metrics(owner=ml_engineer)
+            involves_training = objective_type in ("predictive", "prescriptive", "causal")
+            if involves_training:
+                if not any(isinstance(d, dict) and d.get("required") and d.get("kind") == "metrics"
+                           and d.get("owner") == "ml_engineer" for d in deliverables):
+                    missing.append({
+                        "invariant": "ml_requires_metrics",
+                        "severity": "error",
+                        "message": "Model training objective requires at least one required deliverable with kind='metrics' and owner='ml_engineer'.",
+                        "expected_kind": "metrics", "expected_owner": "ml_engineer",
+                    })
+
+                # INV-3: Model training requires predictions OR submission
+                if not any(isinstance(d, dict) and d.get("required") and d.get("kind") in ("predictions", "submission")
+                           and d.get("owner") == "ml_engineer" for d in deliverables):
+                    missing.append({
+                        "invariant": "ml_requires_predictions_or_submission",
+                        "severity": "error",
+                        "message": "Model training objective requires at least one required deliverable with kind='predictions' or kind='submission' and owner='ml_engineer'.",
+                        "expected_kind": "predictions|submission", "expected_owner": "ml_engineer",
+                    })
+
+            # INV-4: Kaggle/competition requires submission
+            if _detect_submission_requirement():
+                if not any(isinstance(d, dict) and d.get("required") and d.get("kind") == "submission"
+                           and d.get("owner") == "ml_engineer" for d in deliverables):
+                    missing.append({
+                        "invariant": "competition_requires_submission",
+                        "severity": "error",
+                        "message": "Competition/Kaggle objective requires at least one required deliverable with kind='submission' and owner='ml_engineer'.",
+                        "expected_kind": "submission", "expected_owner": "ml_engineer",
+                    })
+
+            return missing
+
+        def _format_invariant_feedback(errors: List[Dict[str, Any]]) -> str:
+            """Format invariant errors into corrective feedback for replan."""
+            lines = ["Your contract is missing required deliverables:"]
+            for err in errors:
+                lines.append(f"- {err['invariant']}: {err['message']}")
+            lines.append("Please add these to spec_extraction.deliverables and required_outputs.")
+            return "\n".join(lines)
+
         def _merge_unique(values: List[str], extras: List[str]) -> List[str]:
             seen: set[str] = set()
             out: List[str] = []
@@ -9303,6 +9373,22 @@ class ExecutionPlannerAgent:
                     strategy=strategy if isinstance(strategy, dict) else {},
                     business_objective=business_objective,
                 )
+                # Apply deliverables canonicalization + auto-sync
+                contract = _apply_deliverables(contract)
+                # Lint deliverable invariants
+                obj_type = _infer_objective_type()
+                invariant_errors = _lint_deliverable_invariants(contract, obj_type)
+                if invariant_errors:
+                    error_items = [e for e in invariant_errors if e.get("severity") == "error"]
+                    if error_items:
+                        print(f"DELIVERABLE_LINT: {len(error_items)} invariant errors detected")
+                        for err in error_items:
+                            print(f"  - {err['invariant']}: {err['message']}")
+                        # Re-apply deliverables with corrective derivation (attempt 2)
+                        contract = _apply_deliverables(contract)
+                        final_errors = _lint_deliverable_invariants(contract, obj_type)
+                        if final_errors:
+                            print(f"DELIVERABLE_LINT: {len(final_errors)} errors persist after replan")
             diagnostics = _build_contract_diagnostics(contract if isinstance(contract, dict) else {}, where, llm_success)
             self.last_contract_diagnostics = diagnostics
             _persist_contracts(
