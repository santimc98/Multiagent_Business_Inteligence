diff --git a/src/utils/contract_accessors.py b/src/utils/contract_accessors.py
index 2e5bc70..e742061 100644
--- a/src/utils/contract_accessors.py
+++ b/src/utils/contract_accessors.py
@@ -958,6 +958,30 @@ def get_required_outputs(contract: Dict[str, Any]) -> List[str]:
     return result
 
 
+def _infer_kind_from_path(path: str) -> str:
+    """Infer deliverable kind from its file path.
+
+    Canonical location for kind inference â€” used as fallback when deliverables
+    lack an explicit 'kind' field.  New contracts SHOULD always have explicit kind.
+    """
+    lower = str(path).lower()
+    if "plots" in lower or lower.endswith((".png", ".jpg", ".jpeg", ".svg")):
+        return "plot"
+    if lower.endswith(".csv"):
+        if "submission" in lower:
+            return "submission"
+        return "dataset"
+    if lower.endswith(".json"):
+        if "metrics" in lower:
+            return "metrics"
+        if "weights" in lower:
+            return "weights"
+        if "alignment" in lower or "report" in lower:
+            return "report"
+        return "json"
+    return "artifact"
+
+
 def _infer_owner_from_path(path: str) -> str:
     """Infer which engineer owns a deliverable based on its path.
 
@@ -991,3 +1015,47 @@ def get_required_outputs_by_owner(contract: Dict[str, Any], owner: str) -> List[
             if _infer_owner_from_path(item) == owner:
                 result.append(item)
     return result
+
+
+def get_deliverables(contract: Dict[str, Any]) -> List[Dict[str, Any]]:
+    """Return canonical deliverables from the contract.
+
+    Source of truth: ``spec_extraction.deliverables`` (rich dicts).
+    Fallback: builds deliverables from ``required_outputs`` (legacy).
+    """
+    if not isinstance(contract, dict):
+        return []
+    spec = contract.get("spec_extraction")
+    if isinstance(spec, dict):
+        deliverables = spec.get("deliverables")
+        if isinstance(deliverables, list) and deliverables:
+            return [d for d in deliverables if isinstance(d, dict) and d.get("path")]
+    # Fallback: build from required_outputs
+    raw = contract.get("required_outputs", [])
+    if not isinstance(raw, list):
+        return []
+    result: List[Dict[str, Any]] = []
+    for item in raw:
+        if isinstance(item, dict):
+            path = item.get("path") or ""
+            result.append({
+                "path": path,
+                "required": bool(item.get("required", True)),
+                "kind": item.get("kind") or _infer_kind_from_path(path),
+                "owner": item.get("owner") or _infer_owner_from_path(path),
+                "description": item.get("description", ""),
+            })
+        elif isinstance(item, str) and item.strip():
+            result.append({
+                "path": item,
+                "required": True,
+                "kind": _infer_kind_from_path(item),
+                "owner": _infer_owner_from_path(item),
+                "description": "",
+            })
+    return result
+
+
+def get_deliverables_by_owner(contract: Dict[str, Any], owner: str) -> List[Dict[str, Any]]:
+    """Return deliverables filtered by owner."""
+    return [d for d in get_deliverables(contract) if d.get("owner") == owner]
